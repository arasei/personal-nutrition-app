// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

//Prisma Client（DB操作用のJSコード）を生成する設定
generator client {
  provider = "prisma-client-js"
}

//「どのDBに」「どうやって」接続するかを指定
datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}


//relationについて
// [] がついた側 = N側
// fields + references がある側 = FKを持つ側

//relation
// Profile ↔ Diagnosis（1:N）
// Diagnosis ↔ DiagnosisAnswer（1:N）

//indexは回答一覧を取る時間を短くするために設定



//Profile
// この人は誰か・診断に使う基本情報・診断の親
// Supabase Userと1:1
// authUserId   String   @uniqueでは、Supabase Authのuser.idを使用


model Profile {
  id           String   @id @default(uuid())
  authUserId   String   @unique

  nickname     String?
  gender       String?
  birth_date   DateTime?
  height       Int?
  weight       Int?

  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  diagnoses    Diagnosis[]
}


//Diagnosis
// この人がこの日にやった1回の診断
// 1回の診断そのもの(イベント・状態を持つ)
// currentStep→途中再開OK
// status→進行中/完了を管理
// 回答ログと1:N

model Diagnosis {
  id             String   @id @default(uuid())
  profile_id     String

  status         String
  current_step   Int?
  started_at     DateTime
  completed_at   DateTime?

  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  profile        Profile @relation(fields: [profile_id], references: [id])
  answers        DiagnosisAnswer[]

  @@index([profile_id])
}


//DiagnosisQuestion
// 質問はマスタ(増えない)
// 全診断共通
// orderで表示順を制御
// 回答ログ(DiagnosisAnswer)と1:N

model DiagnosisQuestion {
  id            String   @id @default(uuid())
  questionText  String
  order         Int      @unique

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  answers      DiagnosisAnswer[]
}


//DiagnosisAnswer
// どの診断で、どの質問に、どう答えたか、いつ答えたかを履歴として保存
// 質問は固定
// 回答は無限に増える
// 診断ごとに独立

// DiagnosisAnswerはDiagnosisとDiagnosisQuestion両方に属する。
// その為、relationが２つ存在する。(中間テーブル的存在)


model DiagnosisAnswer {
  id                 String   @id @default(uuid())
  diagnosis_id       String
  question_id        String

  answer_value       String
  answered_at        DateTime

  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  diagnosis          Diagnosis         @relation(fields: [diagnosis_id], references: [id])
  question           DiagnosisQuestion @relation(fields: [question_id], references :[id])

  @@index([diagnosis_id])
  @@index([question_id])

  //同じ診断×同じ質問は1つだけ
  @@unique([diagnosis_id, question_id])
}
