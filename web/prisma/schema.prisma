//Prisma Client（DB操作用のJSコード）を生成する設定
generator client {
  provider = "prisma-client-js"
}

//「どのDBに」「どうやって」接続するかを指定
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//relationについて
// [] がついた側 = N側
// fields + references がある側 = FKを持つ側

//relation
// Profile ↔ Diagnosis（1:N）
// Diagnosis ↔ DiagnosisAnswer（1:N）

//indexは回答一覧を取る時間を短くするために設定

//Profile
// この人は誰か・診断に使う基本情報・診断の親
// Supabase Userと1:1
// authUserId   String   @uniqueでは、Supabase Authのuser.idを使用

model Profile {
  id         String      @id @default(cuid())
  authUserId String      @unique
  nickname   String?
  gender     String?
  height     Int?
  weight     Int?
  birthDate  DateTime?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  diagnoses  Diagnosis[]
}

//User1人: Diagnosis 複数
model User {
  id        String      @id
  diagnoses Diagnosis[]
}

//Diagnosis
// この人がこの日にやった1回の診断
// 1回の診断そのもの(イベント・状態を持つ)
// currentStep→途中再開OK
// status→進行中/完了を管理
// 回答ログと1:N
//userと紐付け
// userIdはSupabaseAuthのuser.id
//Diagnosisは必ず誰かに属する

model Diagnosis {
  id     String @id
  userId String

  user        User              @relation(fields: [userId], references: [id])
  status      String
  completedAt DateTime?
  createdAt   DateTime          @default(now())
  currentStep Int?
  profileId   String?
  startedAt   DateTime?
  updatedAt   DateTime          @updatedAt
  profile     Profile?          @relation(fields: [profileId], references: [id])
  answers     DiagnosisAnswer[]

  @@index([profileId])
}

//DiagnosisQuestion
// 質問はマスタ(増えない)
// 全診断共通
// orderで表示順を制御
// 回答ログ(DiagnosisAnswer)と1:N

model DiagnosisQuestion {
  id           String            @id @default(cuid())
  questionText String
  order        Int               @unique

  nutrient     String

  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  
  answers      DiagnosisAnswer[]
}

//DiagnosisAnswer
// どの診断で、どの質問に、どう答えたか、いつ答えたかを履歴として保存
// 質問は固定
// 回答は無限に増える
// 診断ごとに独立
//スコア集計が目的

// DiagnosisAnswerはDiagnosisとDiagnosisQuestion両方に属する。
// その為、relationが２つ存在する。(中間テーブル的存在)
// relationの外部キーは必ず参照先と同じ型
// @@unique([diagnosisId, questionId]) → 1診断×1質問 = 1回答を保証

//idはStringの仕様に変更
// (seed.tsのconst diagnosisAnswers内でdiagnosisIdを文字列として扱っているため)
// 意味をあるIDをそのまま使うため

//answerValueをvalue(ただの数値として)に変更
// valueには意味を持たせすぎない仕様
// 回答以外にもvalueの数値(Int)を使うため(スコア、回数、強度、Yes/No(0/1)など)

//diagnosisId / questionId は 意味を持つ識別子なのでStringにする
// 数値IDに変換する理由がない
// フロント・API・seed すべてで同じ値を使える

model DiagnosisAnswer {
  id                String @id @default(cuid())

  diagnosisResultId String
  diagnosisId       String
  questionId        String

  diagnosis       Diagnosis         @relation(fields: [diagnosisId], references: [id])
  question        DiagnosisQuestion @relation(fields: [questionId], references: [id])
  diagnosisResult DiagnosisResult   @relation(fields: [diagnosisResultId], references: [id])

  value Int

  answeredAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@unique([diagnosisId, questionId])
  @@index([diagnosisId])
  @@index([questionId])
}

//DiagnosisResult
//1回の診断というイベント

//idはStringにして、フロント・API・seedで全て統一

model DiagnosisResult {
  id          String            @id @default(cuid())
  userId      String
  diagnosisId String
  createdAt   DateTime          @default(now())
  answers     DiagnosisAnswer[] 
}
